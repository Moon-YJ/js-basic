<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <title>Document</title>
  <link rel='stylesheet' href='style.css'>
</head>

<body>
  <div id="box"></div>
  <p>집에서 한 작업 test</p>

  <script>

    /*
      - 자바스크립트는 Interpreter language(인터프리터 언어)
        : 컴파일이라는 단계(기계어로 변환)를 거치지않고(=컴파일러 언어) 모든 브라우저에 내장이 돼서 실시간으로 동작하는 언어
      - 최근 들어 자바스크립트가 뜨는 이유
        : 기존 브라우저 성능이 안좋아서 코드개발의 간편함보다는 성능 중심의 개발을 하다보니 java, c같은 컴파일 언어가 대세
        : 전반적인 사용자 시스템이 좋아지면서 개발시 굳이 성능을 예전처럼 고려할 필요가 없어지다보니 간편한 인터프리터 방식의 개발을 선호
      - 자바스크립트는 대표적인 비동기 동작 방식
        : 동기적 동작 방식 = 입력한 순서대로(순차적으로) 실행되는 방식
        : 비동기적 동작 방식 = 입력한 순서대로가 아닌 동시에 실행되는 방식
      - 자바스크립트에서 DOM을 제어할 때 문제가 발생하는 경우
      - 자바스크립트가 비동기적으로 동작하는 이유
        : 자바스크립트는 브라우저(web api)에 내장돼서 브라우저 기능과 상호적으로 작업하기 때문에
        : 특정 업무를 자바스크립트와 web api가 분담해서 처리하므로 특정 작업의 순서를 특정하기 어려움

      - 자바스크립트가 비동기적으로 동작하면서 발생하게 되는 대표적인 오류 사례
        : 브라우저를 통해서 유튜브 서버로부터 유튜브 데이터를 가져옴 (=web api가 처리)
        : 해당 유튜브 데이터를 통해서 자바스크립트를 이용해서 동적 DOM 생성 (=js)
        : 위 사례의 경우, 자바스크립트가 비동기적으로 동작하기 때문에 아직 데이터가 다 받아지지 않아도 js가 돔 생성을 시작하면서 오류 발생
        : 위와 같은 에러상황을 runtime 에러라고 함
        : runtime error = 사용자가 실 서비스를 이용하는 도중에 발생하는 에러
      
      ==> 프론트엔드 개발자가 제일 신경 써야할 작업
          : 비동기로 발생하는 작업흐름을 강제로 동기화 시키는 작업(promise)
      
      - 자바스크립트의 구조
        : call stack (특정 업무를 실행하는 공간)
          => 자바스크립트는 콜스택이 하나밖에 없는 단일쓰레드 방식
          => 자바스크립트 명령어를 순차적으로 실행
          => 변수 선언시 메모리를 할당하거나 원시형 자료(문자, 숫자, boolean)같은 간단한 자료구조는 저장 가능
        : memory heap (임시로 특정 데이터를 저장하는 공간)
          => 데이터 크기를 확정하기 힘든 대용량 데이터나 참조형 자료(배열, 객체)가 저장되는 공간
          => memory heap에 저장되는 값은 자바스크립트에 내장되어있는 garbage collector에 의해서 정기적으로 안쓰는 메모리들은 삭제됨
    */

    /*
      - 핵심 요약(무조건 알아야 함)
        : 자바스크립트는 브라우저(web api)에 내장되어 서로 상호보완적으로 동작됨 (인터프리터 언어)
        : 따라서 자바스크립트는 비동기 방식으로 동작됨 (입력한 순서대로 동작되지 않을 수 있음)
        : 자바스크립트에서 비동기가 발생하는 상황을 강제로 동기화 시키는 작업 이슈가 많음(promise)
      
      - 핵심 요약(무조건 알아야 함)
        1. 변수 = 자주쓰는 값을 담아서 재활용하기 위한 임시 공간
        : let = 자주 바뀔만한 값은 let 방식으로 만든 변수에 담는다
        : const = 바뀌면 안되는 중요한 값은 const 방식으로 만든 변수에 담는다

        : let a = 'test'; // a라는 변수에 'test'라는 문자를 저장
        : a = 'test2' // a변수는 let 선언방식이라 추후 덮어쓰기 가능
        : const myName = '홍길동'; //myName이라는 변수에 '홍길동'  이름 저장 (myName const 선언방식이라 덮어쓰기 불가능)
        ---------------------------
        2. 문자열 vs 숫자
        : 문자 = 따옴표로 감싸서 표현
        : 숫자 = 숫자만 입력
      
        : 강제로 숫자나 변수가 문자화되는 경우 = 따옴표로 감싸는 순간
        ----------------------------
        3. 연산자 = 특정 값을 도출하기 위한 연산식별자 (산술연산자, 비교연산자, 대입연산자)
        :산술연산자는 숫자값 연산
        :비교연산자는 복수개의 값을 비교해서 true, false 반환
        :대입연산자는 우항을 연산된 결과값을 좌항에 대입(=)
        :복합대입연산자 = 대입연사자와 산술연산자가 결합된 형태
        -----------------------------
        4. 조건문 (조건식의 결과에 따라 분기처리)
        :비교연산자를 활용해서 반환되는 true, false값에 따라의 코드의 분기처리
        if(조건식1){
          만약 조건식1이 true면 해당 코드블록을 실행하고 조건문 중지
          조건식1이 false면 해당 코드블록 무시하고 다음 조건식 넘어감
        }
        else if(조건식2){
          만약 조건식2가 true면 해당 코드블록을 실행하고 조건문 중지
          조건식2가 false면 해당 코드블록 무시하고 다음 조건식 넘어감
        }
        else {
          위의 조건식들이 모두 false면 어쨌든 조건식 종료를 위해서 
          해당 구문의 코드블록 실행하고 조건문 종료
        }

        실제 개발시 제일 많이 활용될 패턴이고
        :조건이 여러개 있을때 해당 구문을 반복처리하기 위함
        :만약 아래 조건식에 부합되는 경우가 없으면 아무코드도 실행되지 않음
        if(조건식1){실행할 코드블록}
        if(조건식2){실행할 코드블록}
        if(조건식3){실행할 코드블록}

        //특정 조건일때 딱 한줄의 코드만 실행되면 되고
        //특정 조건이 아니면 아무일도 발생시키지 않을때 아래와 같은 표현식 많이씀
        if(조건식) 실행할 코드한줄;
        -----------------------------
        5. 배열
        : 배열 = 같은 성격의 여러개의 값들을 그룹화할때 쓰는 자료형
        : const 변수명  = [값1, 값2, 값3];
        : 배열값을 뽑을때는 = 배열이 있는 변수명[순번]; //프로그래밍 언어에서는 첫번째 순번이 1이 아닌 0
        : 배열을 쓰는 이유(배열로 굳이 같은 성격의 데이터를 묶어두는 이유) = 반복문을 써서 자동화 처리하기 위함
        : 배열의 갯수를 구하는 방법 = 배열명.length
        const colors = ['red', 'green', 'blue', 'orange'];
        console.log(colors[0]); // 'red'
        console.log(colors.length);
        -----------------------------
        6. 객체
        : 여러개의 값을 그룹화 (자료구조가 복잡할때)
        const iphone1 = {
          price: 1000, //property
          color: 'white', //key : values
          isSale: false
        }
        console.log(iphone1);
        // 객체값을 뽑을떄
        console.log(iphone1.price)
        console.log(iphone1['color'])
        // 객체값 추가할때
        iphone1.weight = '1kg';
        console.log(iphone1);
    */

    /*
    //console.log(6 % 4); // %는 특정 값을 나누는 연산자가 아닌 나눈 몫의 나머지를 구하는 연산자
    // 백엔드 개발에서 페이지 개수 구할때 사용
    // ex. 게시글 10갠데 3개씩 보이고 싶을때(페이지 총 4개 필요): 나머지가 0이면 몫만큼의 페이지 개수만 필요, 나머지가 0이 아니면 몫+1만큼의 페이지 개수 필요
    // console.log(4 !== '4'); // == 값만 비교, === 값이랑 자료형 같이 비교, != 값이 달라야 true
    //let num; //변수 선언 (메모리를 만들어서 num이라는 이름 붙임)
    //num = 1; //변수에 값 할당 (num이라는 메모리 공간에 1이라는 대입해서 저장)
    let num = 1; //변수를 초기화 (메모리 할당과 동시에 값 대입)
    //num = num + 1; //자기자신값에 1을 더한 값을 다시 자기자신에 재할당
    //num += 1;
    //num++;
    num--;
    console.log(num);

    console.log(true && false) //&&연산자는 복수개의 값이 모두 true여야지 true로 인지
    console.log(true || false) //복수개의 값중에 하나만이라도 true면 true로 인지

    - 변수명 작성시 주의점
      1.변수명 숫자로 시작 불가
      2.변수명 가급적 영어로
      3.변수명 대소문자 구분
      4.변수명에 특수문자 사용불가 (_, $는 사용가능)
    */

    const hour = new Date().getHours();
    document.body.style.backgroundColor = 'aqua';

    if (hour >= 5 && hour < 11) {
      document.body.style.backgroundColor = 'orange';
    } else if (hour >= 11 && hour < 15) {
      document.body.style.backgroundColor = 'lightblue';
    } else if (hour >= 15 && hour < 19) {
      document.body.style.backgroundColor = 'pink';
    } else {
      document.body.style.backgroundColor = 'black';
    }

    console.log(hour);

  </script>
</body>

</html>