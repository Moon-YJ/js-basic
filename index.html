<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <title>Document</title>
  <link rel='stylesheet' href='style.css'>
</head>

<body>
  <script>

    /*
    자바스크립트의 자료형 (Data Type)
    1. 원시형 자료 (primitive type)
      - 문자열 (String)
      - 숫자 (Number)
      - 논리형자료 (Boolean, true, false)
      - undifined (undefined)
    2. 참조형 자료 (reference type)
      - 배열 (Array:Object)
      - 객체 (Object)
      - null (Object)
    3. undefined vs null
      - undefined : 변수를 선언하고 값을 할당하지 않았을때 시스템이 자동으로 넣어주는 값
      - 특정 값을 찍었을떄 undefined나오는 경우는 에러상황: 있어야될 메모리값이 없을떄
      - null : 일부러 명시적으로 값을 비워둘때;
      - null은 에러상황은 아니고 추후에 어떤 값을 담을 변수를 만들긴 해야되는데 담을 값이 없을떄 null할당
    4. 객체의 property에 변수 연결하는 법
      - ES6이후로 객체의 property key값을 변수로 치환가능해짐
      - 객체의 property key를 대괄호로 묶으면 변수 활용가능
    5. 자바스크립트 데이터의 자료형 확인하는 법
      - typeof 값 : 해당값의 자료형이 문자값으로 반환
      ==> let data = null; console.log(typeof data); // Object
    */

    /*
      원시형자료 vs 참조형 자료

      1. 원시형 자료 
        - 메모리에 물리적으로 해당 값이 담기는 자료형
        - 메모리에 값만 담김
        - 값의 크기가 비교적 명확
        - 메모리 선언과 원시형자료 값 자체가 모두 callstack에서 이루어짐
        - 종류: string, number, boolean, undefined
      2. 참조형 자료 
        - 메모리에 해당값 자체가 아닌 해당 값의 위치값이 참조되는 자료형
        - 메모리에 해당값의 위치값만 참조되는 것이 아닌 해당값으로 활용할 수 있는 여러가지 메서드(함수)도 같이 참조됨
        - 값의 크기를 구체적으로 산정하기 어려움
        - 메모리 선언은 callstack에서 일어나지만 값은 힙메모리(memory heap)에 저장되므로 힙메모리에 있는 위치값만 콜스택 변수에 참조됨
        - 종류: array, object
        - const는 재할당이 불가능
        - 기존 참조형 자료는 배열, 객체의 변수로 복사시 원본복사가 안됨 (Shallow Copy: 얕은 복사)
          => 기존 배열을 단순히 변수에 옮겨담을시
    */

    /*
      전개연산자 (Spread Operator)
      - 참조형 자료를 완전 복사 (Deep Copy, 불변성 유지됨)
      - heap memory에 있는 값을 물리적으로 복사
    */

    /*
      비구조화할당, 구조분해할당 (Destructuring Assignment)
      - 비구조화할당으로 객체나 배열의 값들을 편하게 변수로 추출
      - 객체나 배열의 기존 구조를 분해해서 각각의 값으로 재할당
      - 배열은 비구조화할당시 변수명 임의로 지정 가능
      - 객체는 무조건 property key값으로 변수명 지정해야함
    */

    //아래의 경우는 실제로 data메모리공간에 'game'이라는 원시형 자료값이 물리적으로 들어있기때문에
    //새로운 원시형 자료값을 대입을 하면 값자체가 변경되는 재할당이 일어나면서 에러
    const data = 'game';
    //data = 3;
    //console.log(data);

    //colors라는 메모리에는 callstack에 배열값 자체가 담기는게 아닌 힙메모리에 있는 해당값의 위치값만 참조됨
    const colors = ['red', 'green', 'blue'];
    //해당 참조링크는 동일한 상태에서 참조링크가 가리키고 있는 첫번째 값을 변경하는 것이기 때문에
    //callstack에 있는 colors변수에 참조링크가 변경되는 것은 아니므로 참조형자료의 값들은 const 선언방식이라도 기본 구조를 유지하고 있으면(재할당은 불가능) 값의 추가나 제거, 변경은 가능
    colors[0] = 'hotpink';
    console.log(colors);
    //하지만 아래처럼 아래 새롭게 값을 재할당 하려고 하면 변수에는 새로운 참조링크가 할당되므로
    //callstack에 있는 변수에 새로운 참조링크가 재할당되는 것이므로 에러발생
    // colors = [1, 2, 3]; //error

    let test;
    console.log(test);

    let youtubeData = null;
    console.log(youtubeData);
    youtube = '추후에 담길 유튜브 데이터';

    let name = 'abc';
    const student = {
      [name]: 'David'
    }
    console.log(student.abc) //David

    // 얕은 복사(Shallow Copy)
    const newColors = colors;
    newColors[0] = 'hotpink';
    // 원본 데이터가 아닌 참조링크가 복사돼서 불변성 유지가 안됨 (=> 두개 배열값이 모두 변경됨)
    console.log('colors:::', colors)
    console.log('newColors:::', newColors)

    // 전개 연산자(Spread Operator)
    const interests = ['game', 'movie', 'webtoon'];
    console.log(...interests);
    const newInterests = [...interests];
    newInterests[2] = 'reading';

    console.log('interests:::', interests);
    console.log('newInterests:::', newInterests);

    const student2 = {
      name: 'James',
      age: 20,
      school: 'uni'
    }
    const newStudent = { ...student2 };
    newStudent.age = 22;
    console.log('new::', newStudent);
    console.log('origin::', student2);
    // 작년 회원가입 정보
    const student3 = {
      name: 'Michelle',
      age: 20,
    }
    // 올해 회원가입 정보
    const extraInfo = {
      name: 'Michelle',
      age: 21,
      hobboy: 'game'
    }
    // 작년회원가입 정보값을 유지하면서 올해 회원가입 정보값을 업데이트하는 새로운 데이터 추가
    // 전개 연산자를 이용하면 원본을 유지하면서 기존 2개의 객체값을 합칠 때 유용
    const newStudent3 = { ...student3, ...extraInfo }
    console.log('student3::', student3);
    console.log('extraInfo::', extraInfo);
    console.log('newStudent3::', newStudent3);

    // 문자열에 변수를 쉽게 삽입하는법 'Template literal'
    const name2 = '홍길동';
    const age2 = 20;
    const address2 = '서울';
    intro(name2, age2, address2);
    function intro(name, age, address) {
      console.log(`제 이름은 ${name}이고 나이는 ${age + 1}살이며 사는 곳은 ${address}입니다`);
    }

    // 구조분해할당
    // 배열
    const [color1, color2, color3] = colors;
    console.log(color1);
    console.log(color2);
    console.log(color3);
    /*
      const name3 = student2.name;
      const age3 = student2.age;
      const school3 = student2.school;  
    */
    // 객체
    const student1 = {
      name: 'David',
      age: 20,
      isFemale: false
    }
    /*
    const name = student1.name;
    const age = student1.age;
    const isFemale = student1.isFemale;
    console.log(age);
    */
    //const name3 = '홍길동';
    //뽑아낼때에는 key값으로 뽑아야 되지만 다시 다른값으로 변경처리 가능
    const { name: user_name, age, isFemale } = student1;
    console.log(user_name);
    console.log(age);
    console.log(isFemale);

    const { hobby: user_hobby, gender: user_gender, school: user_school } = {
      hobby: 'riding a bike',
      gender: 'female',
      school: 'undergraduate',
    }
    console.log(user_hobby);
    console.log(user_gender);
    console.log(user_school);
  </script>
</body>

</html>